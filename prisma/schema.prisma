// Prisma가 이 TypeScript 코드에 대한 javascript 코드를 어디에 어떻게 생성할지 정의하는 블록
generator client {
  // provider는 Prisma가 어떤 종류의 코드를 생성할지 지정하는 필드임
  // typescript/javascript 용 Prisma Client를 생성하는 것이기 때문에 이 값은 바꾸면 안됨(고정값임)
  provider = "prisma-client-js"
  // Prisma Client를 내가 정의한 경로에 생성하겠다는 의미
  // 보통 Prisma Client는 node_modules/.prisma/client/index.js 위치에 생성됨.
  // 그래서 일반적인 경로에 생성되게 하는게 더 나음
  // output   = "../generated/prisma"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

enum Role{
  ADMIN
  USER
}

enum SubmissionResult {
  ACCEPTED         // 맞았습니다!!
  WRONG_ANSWER     // 틀렸습니다
  TIME_LIMIT       // 시간 초과
  RUNTIME_ERROR    // 런타임 에러
  COMPILE_ERROR    // 컴파일 에러
  MEMORY_LIMIT     // 메모리 초과
  OUTPUT_LIMIT     // 출력 초과
  OUTPUT_FORMAT_ERROR // 출력 형식이 잘못되었습니다
}

enum Tag{
  MAZE_RUNNER // 메이즈러너 - BFS DFS 문제 해결
  HANZEL_AND_GRETEL // 헨젤과그레텔 - 백트래킹 문제 해결
  ARCHIMEDES // 아르키메데스 - 수학 해결
  OPTIMIZER // 최적화의 달인 - DP 해결
  HEAD_FIRST// 맨땅에 헤딩 - 브루트포스 해결
  ZERO_TO_HERO // 무에서유 - 구현 해결
  RIGHT_OR_LEFT // 이분탐색 해결
  // 문자열 해결
  // 정렬 해결
  // 그리디 해결
  // 자료구조 해결
  // 시뮬레이션 해결
  BOY_SCOUT // 그래프 문제 해결 -> 탐색 해결?
  PRO_FINESSE  // 해결사 - 문제 30개 해결
  HARD_WORKER // 하드워커 - 10일 연속 문제풀이 시도
  TIME_KEEPER // 시간의 지배자 - 시간초과 10개 이상
  MISSING // 행방불명자 - 한 달 동안 연속 문제풀이 시도 X
}

enum SolvedAcTier {
  Unranked
  Bronze5
  Bronze4
  Bronze3
  Bronze2
  Bronze1
  Silver5
  Silver4
  Silver3
  Silver2
  Silver1
  Gold5
  Gold4
  Gold3
  Gold2
  Gold1
  Platinum5
  Platinum4
  Platinum3
  Platinum2
  Platinum1
  Diamond5
  Diamond4
  Diamond3
  Diamond2
  Diamond1
  Ruby5
  Ruby4
  Ruby3
  Ruby2
  Ruby1
}

model ProblemTags {
  // 총 문제 4만개라고 하고 각 문제마다 태그가 5개여도
  // 20만개로 Int 안에서 충분히 가능
  id Int @id @db.UnsignedMediumInt @default(autoincrement())

  problem Problems @relation(fields:[problemId], references: [id])
  problemId Int @db.UnsignedMediumInt

  tag String

  @@map("problem_tags")
}

model Problems {
  // INSERT할때 직접 PK 값 지정해주어야함
  // id 값은 백준에서 지정한 문제 번호
  // 현재 총 문제 3만개. 그래도 넉넉하게 65000개는 받을 수 있도록 타입 설정
  id Int @id @db.UnsignedMediumInt

  title String

  // api로 받은 level을 Enum과 매핑해서 저장됨
  tier SolvedAcTier

  submissions Submissions[]

  problemTags ProblemTags[]

  @@map("problems")
}

// 문제풀이 제출 기록
// 이거 그냥 solutionId를 PK값으로 둘까??
// 근데 이러면 BTree 정렬될때 ㅈ되는데...
// 매번 새 solutionId 들어올때마다 BTree 정렬해야하는데 이거 그럼 개느리겠는데??
// 걍 PK는 autoincrement해놓고 solutionId에 인덱싱해놓는게 더 나을듯
// submission 조회할때 solutionId로 정렬해서 내보내니까
model Submissions {
  // 20억개를 넘을 일은 없음!
  id Int @id @default(autoincrement())

  // 백준에서 지정된 값을 그대로 사용
  // 40억을 넘을 수 있음
  // 특정 날짜 이전것을 삭제할때 이것을 기준으로 해도 됨
  solutionId Int @db.UnsignedInt
  
  user Users @relation(fields: [name], references: [name])
  name String

  problem Problems @relation(fields:[problemId], references: [id])
  problemId Int @db.UnsignedMediumInt

  result SubmissionResult @default(WRONG_ANSWER)

  // memory는 UnsignedSmallInt(65,000)는 넘음
  memory Int @db.UnsignedMediumInt
  // time은 UnsignedSmallInt(65,000)를 넘지는 않음
  time Int @db.UnsignedSmallInt
  language String
  codeLength Int

  // 시간 분 초 단위까지 저장해야하기 때문에 TIMESTAMP형으로 저장
  submittedAt DateTime @db.Timestamp()

  @@map("submissions")
}

model Users {
  id          String @id @default(uuid())
  name    String @unique @db.VarChar(20)
  password    String @db.VarChar(255)
  skippedCnt Int    @default(0)
  role        Role   @default(USER)

  tier SolvedAcTier // 유저 현재 티어

  solvedCount Int // 맞은 총 문제수

  streaks Int // 현재 스트릭

  averageTries Decimal @db.Decimal(3,2) @default(0) // 평균 시도 횟수 - 문제를 보통 몇 번만에 맞추는지 (전체 3자리로 정수 1자리 소수점 2자리)
  
  joinedAt DateTime @db.Timestamp() // 백준 시작 날짜

  // 한 명의 유저는 여러 그룹의 그룹장이 될 수 있음
  // Users와 Groups는 일대다 관계
  managingGroups Groups[]

  // 한 명의 유저는 여러 그룹에 속할 수 있음
  // Users와 GroupMembership은 일대다 관계
  groups GroupMemberships[]

  // 한 명의 유저는 여러 커밋 내역이 존재
  submissions Submissions[]

  @@map("users")
}

model GroupMemberships {
  id Int @id @default(autoincrement())

  user   Users @relation(fields: [userId], references: [id])
  userId String

  group   Groups @relation(fields: [groupId], references: [id])
  groupId Int

  joinedAt DateTime @db.Timestamp() @default(dbgenerated("CURRENT_TIMESTAMP"))

  @@unique([userId, groupId])
  @@map("group_memberships")
}

// SELECT * FROM `groups`;
model Groups {
  id   Int       @id @default(autoincrement())
  name String    @unique @db.VarChar(100) // 그룹 이름

  description String // 그룹 설명

  // 모든 그룹에는 한 명의 그룹장만 존재
  manager   Users @relation(fields: [managerId], references: [id])
  managerId String 

  managerName String @db.VarChar(100) // 매니저 이름
  
  users GroupMemberships[]

  // Group 생성날짜 같은 경우에는 TimeStamp로 둘 필요가 없음
  // 시간 분 초 밀리초는 필요없기 때문에 DB에서는 Date 형으로 저장하려고 했으나
  // Prisma에서 지원을 안하네?
  // 그래서 TimeStamp로 저장하고 값을 return할때 DATE(createdAt)으로 날짜만 반환받을 수 있게 하기로 함
  // DateTime으로 저장하면 서버 시간대를 반영못하기 때문에 내가 추가적인 계산 +09:00 을 해줘야함
  // Date로 저장하면 UTC 기준으로 저장해놓고 반환할때 추가적인 계산을 해주던가 아예 저장할때 +09:00의 결과를 저장해줘야함
  // 근데 이렇게 내가 추가적으로 저장해주는 것보다 그냥 시간대 반영을 DB 서버나 브라우저에 위임하는게 좋을듯?
  // 그래서 그냥 TimeStamp형으로 저장하기로 결정함
  // createdAt DateTime @db.Timestamp() @default(dbgenerated("NOW"))
  createdAt DateTime @db.Timestamp() @default(dbgenerated("CURRENT_TIMESTAMP"))
  
  @@map("groups")
}
